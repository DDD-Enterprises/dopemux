#!/bin/bash

# Dopemux - Smart Multi-Instance Manager
# Auto-detects running instances and manages git worktrees
#
# Usage:
#   dopemux start [instance] [branch]    - Start or create instance
#   dopemux stop [instance]              - Stop instance
#   dopemux status                       - Show all instances
#   dopemux list                         - List available instances
#   dopemux switch <instance>            - Switch to instance worktree
#   dopemux clean                        - Clean up stopped instances

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
log_error() { echo -e "${RED}‚ùå $1${NC}"; }
log_header() { echo -e "${PURPLE}üöÄ $1${NC}"; }

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
WORKTREE_ROOT="$(cd "$PROJECT_ROOT/.." && pwd)/dopemux-instances"

# Function to detect running instances
detect_running_instances() {
    local running_instances=()

    # Check for running containers with mcp.instance label
    if command -v docker &> /dev/null; then
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                running_instances+=("$line")
            fi
        done < <(docker ps --filter "label=mcp.instance" --format "{{.Label \"mcp.instance\"}}" 2>/dev/null | sort -u)
    fi

    printf '%s\n' "${running_instances[@]}"
}

# Function to detect main hub instance
detect_main_instance() {
    # Check for running containers with mcp.role=hub label
    if command -v docker &> /dev/null; then
        docker ps --filter "label=mcp.role=hub" --format "{{.Label \"mcp.instance\"}}" 2>/dev/null | head -1
    fi
}

# Function to check if main instance shared services are healthy
check_main_instance_health() {
    local main_instance="$1"
    local services=("conport:3004" "milvus:19530" "redis:6379")
    local all_healthy=true

    log_info "Checking main instance '$main_instance' shared services..."

    for service in "${services[@]}"; do
        local service_name="${service%:*}"
        local port="${service#*:}"

        if ! nc -z localhost "$port" 2>/dev/null; then
            log_warning "‚ùå $service_name (port $port) not responding"
            all_healthy=false
        else
            log_info "‚úÖ $service_name (port $port) healthy"
        fi
    done

    if [[ "$all_healthy" == true ]]; then
        log_success "All shared services healthy on main instance '$main_instance'"
        return 0
    else
        log_error "Some shared services unhealthy on main instance '$main_instance'"
        return 1
    fi
}

# Function to get next available port
get_next_port() {
    local base_port=3000
    local used_ports=()

    # Get ports from running instances
    if command -v docker &> /dev/null; then
        while IFS= read -r port; do
            if [[ -n "$port" && "$port" =~ ^[0-9]+$ ]]; then
                used_ports+=("$port")
            fi
        done < <(docker ps --format "{{.Ports}}" 2>/dev/null | grep -oE '0\.0\.0\.0:[0-9]+' | cut -d: -f2 | sort -n)
    fi

    # Find next available port base (multiple of 30)
    while true; do
        local port_in_use=false
        for used_port in "${used_ports[@]}"; do
            if (( used_port >= base_port && used_port < base_port + 30 )); then
                port_in_use=true
                break
            fi
        done

        if [[ "$port_in_use" == false ]]; then
            echo "$base_port"
            return
        fi

        base_port=$((base_port + 30))

        # Safety check - don't go beyond reasonable range
        if (( base_port > 4000 )); then
            log_error "No available port ranges found"
            exit 1
        fi
    done
}

# Function to show status
show_status() {
    log_header "Dopemux Multi-Instance Status"
    echo

    local running_instances
    mapfile -t running_instances < <(detect_running_instances)

    if [[ ${#running_instances[@]} -eq 0 ]]; then
        log_info "No instances currently running"
        echo
        log_info "Available worktrees:"
        if [[ -d "$WORKTREE_ROOT" ]]; then
            for dir in "$WORKTREE_ROOT"/*; do
                if [[ -d "$dir" ]]; then
                    local instance_name=$(basename "$dir")
                    local branch
                    cd "$dir" 2>/dev/null && branch=$(git branch --show-current 2>/dev/null || echo "unknown")
                    echo "  üìÅ $instance_name (branch: $branch)"
                fi
            done
        else
            echo "  (none created yet)"
        fi
    else
        log_success "${#running_instances[@]} instance(s) running:"
        echo

        # Show hub instance first
        local main_instance
        main_instance=$(detect_main_instance)

        if [[ -n "$main_instance" ]]; then
            echo -e "${GREEN}üè¢ HUB Instance: $main_instance${NC}"
            show_instance_details "$main_instance" "hub"
            echo
        fi

        # Show spoke instances
        local spoke_instances=()
        for instance in "${running_instances[@]}"; do
            if [[ "$instance" != "$main_instance" ]]; then
                spoke_instances+=("$instance")
            fi
        done

        if [[ ${#spoke_instances[@]} -gt 0 ]]; then
            echo -e "${BLUE}üîå SPOKE Instances:${NC}"
            for instance in "${spoke_instances[@]}"; do
                show_instance_details "$instance" "spoke"
            done
        fi
    fi
}

# Function to show detailed instance info
show_instance_details() {
    local instance="$1"
    local role="${2:-unknown}"

    # Get container info
    local containers
    mapfile -t containers < <(docker ps --filter "label=mcp.instance=$instance" --format "{{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null)

    if [[ ${#containers[@]} -gt 0 ]]; then
        echo "  üê≥ Containers:"
        for container_info in "${containers[@]}"; do
            IFS=$'\t' read -r name status ports <<< "$container_info"
            echo "    ‚ñ∂ $name ($status)"
            if [[ -n "$ports" ]]; then
                echo "      üîå Ports: $ports"
            fi
        done
    fi

    # Get worktree info
    local worktree_path="$WORKTREE_ROOT/$instance"
    if [[ -d "$worktree_path" ]]; then
        cd "$worktree_path" 2>/dev/null || {
            echo "  ‚ö†Ô∏è  Worktree path inaccessible: $worktree_path"
            return
        }
        local branch=$(git branch --show-current 2>/dev/null || echo "unknown")
        local commit=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        echo "  üå≥ Worktree: $worktree_path"
        echo "  üåø Branch: $branch ($commit)"

        if [[ "$role" == "hub" ]]; then
            echo "  üè¢ Role: Main Hub (provides shared services)"
        elif [[ "$role" == "spoke" ]]; then
            echo "  üîå Role: Child Spoke (connects to hub)"
        fi
    fi
    echo
}

# Function to start an instance
start_instance() {
    local instance_name="${1:-}"
    local branch="${2:-main}"

    # Detect current state
    local running_instances
    mapfile -t running_instances < <(detect_running_instances)
    local main_instance
    main_instance=$(detect_main_instance)

    # If no instance name provided, auto-generate based on running instances
    if [[ -z "$instance_name" ]]; then
        if [[ ${#running_instances[@]} -eq 0 ]]; then
            instance_name="main"
            log_info "No running instances detected, creating 'main' hub instance"
        else
            # Auto-generate next instance name
            local counter=1
            while [[ " ${running_instances[*]} " =~ " dev${counter} " ]]; do
                ((counter++))
            done
            instance_name="dev${counter}"
            log_info "Detected running instances: ${running_instances[*]}"
            log_info "Creating new child instance: $instance_name"
        fi
    fi

    # Check if instance is already running
    if [[ " ${running_instances[*]} " =~ " $instance_name " ]]; then
        log_warning "Instance '$instance_name' is already running"
        log_info "Use 'dopemux switch $instance_name' to open its worktree"
        return 0
    fi

    # Determine if this will be hub or spoke
    local instance_role="spoke"
    local port_base

    if [[ -z "$main_instance" ]]; then
        # This will be the first instance - make it the hub
        instance_role="hub"
        port_base=8000  # Hub uses 8000-8099 for shared services
        log_header "Starting Dopemux HUB instance: $instance_name"
        log_info "üè¢ Role: Main Hub (provides shared services)"
        log_info "üì° Port range: 8000-8099 (shared services)"
        log_info "üåø Branch: $branch"
    else
        # This will be a spoke instance
        port_base=$(get_next_port)
        log_header "Starting Dopemux SPOKE instance: $instance_name"
        log_info "üîå Role: Child Spoke (connects to hub)"
        log_info "üè¢ Hub instance: $main_instance"
        log_info "üì° Port base: $port_base"
        log_info "üåø Branch: $branch"

        # Check hub health before starting spoke
        if ! check_main_instance_health "$main_instance"; then
            log_error "Cannot start spoke instance - hub services unhealthy"
            log_info "Try: dopemux stop $main_instance && dopemux start $main_instance"
            exit 1
        fi
    fi

    # Use the launch-instance script with role information
    cd "$SCRIPT_DIR"

    # Set environment variables for launch script
    export DOPEMUX_INSTANCE_ROLE="$instance_role"
    export DOPEMUX_MAIN_INSTANCE="$main_instance"

    ./launch-instance.sh "$instance_name" "$port_base" "$branch"

    # Start the instance
    local instance_dir="instance-$instance_name"
    if [[ -f "$instance_dir/start.sh" ]]; then
        log_info "Starting services..."
        ./"$instance_dir/start.sh"
        log_success "Instance '$instance_name' started successfully!"

        if [[ "$instance_role" == "hub" ]]; then
            log_info "üè¢ Hub Services:"
            echo "  üíæ ConPort: http://localhost:3004"
            echo "  üîç Milvus: http://localhost:19530"
            echo "  üì° Redis: localhost:6379"
            echo "  üåê Context7: http://localhost:3002"
            echo "  ü§ñ Zen: http://localhost:3003"
            echo
            log_info "‚ö° Other instances can now connect to this hub"
        else
            log_info "üîå Spoke Services (connected to hub):"
            echo "  üåê Context7: http://localhost:$((port_base + 2))"
            echo "  ü§ñ Zen: http://localhost:$((port_base + 3))"
            echo "  üîç Claude Context: http://localhost:$((port_base + 7))"
            echo "  üíæ Shared ConPort: http://localhost:3004 (via hub)"
            echo "  üéØ Shared Milvus: http://localhost:19530 (via hub)"
        fi

        echo
        log_info "Worktree path: $WORKTREE_ROOT/$instance_name"
        log_info "Use 'dopemux switch $instance_name' to open the worktree"
    else
        log_error "Failed to create instance startup script"
        exit 1
    fi
}

# Function to stop an instance
stop_instance() {
    local instance_name="${1:-}"

    if [[ -z "$instance_name" ]]; then
        log_error "Instance name required for stop command"
        echo "Usage: dopemux stop <instance_name>"
        exit 1
    fi

    log_header "Stopping Dopemux instance: $instance_name"

    cd "$SCRIPT_DIR"
    local instance_dir="instance-$instance_name"

    if [[ -f "$instance_dir/stop.sh" ]]; then
        ./"$instance_dir/stop.sh"
        log_success "Instance '$instance_name' stopped successfully!"
    else
        log_warning "No stop script found for instance '$instance_name'"
        # Try to stop containers directly
        docker ps --filter "label=mcp.instance=$instance_name" --format "{{.Names}}" | xargs -r docker stop
        log_info "Stopped containers for instance '$instance_name'"
    fi
}

# Function to switch to an instance worktree
switch_instance() {
    local instance_name="${1:-}"

    if [[ -z "$instance_name" ]]; then
        log_error "Instance name required for switch command"
        echo "Usage: dopemux switch <instance_name>"
        exit 1
    fi

    local worktree_path="$WORKTREE_ROOT/$instance_name"

    if [[ ! -d "$worktree_path" ]]; then
        log_error "Worktree for instance '$instance_name' does not exist"
        log_info "Use 'dopemux start $instance_name' to create it"
        exit 1
    fi

    log_info "Switching to instance: $instance_name"

    cd "$SCRIPT_DIR"
    local instance_dir="instance-$instance_name"

    if [[ -f "$instance_dir/open.sh" ]]; then
        ./"$instance_dir/open.sh"
    else
        log_info "Worktree path: $worktree_path"
        if command -v claude &> /dev/null; then
            log_info "Run: cd $worktree_path && claude"
        else
            log_info "Navigate to: $worktree_path"
        fi
    fi
}

# Function to list instances
list_instances() {
    log_header "Available Dopemux Instances"
    echo

    if [[ ! -d "$WORKTREE_ROOT" ]]; then
        log_info "No instances created yet"
        log_info "Use 'dopemux start' to create your first instance"
        return
    fi

    local running_instances
    mapfile -t running_instances < <(detect_running_instances)

    for dir in "$WORKTREE_ROOT"/*; do
        if [[ -d "$dir" ]]; then
            local instance_name=$(basename "$dir")
            local status="stopped"

            if [[ " ${running_instances[*]} " =~ " $instance_name " ]]; then
                status="running"
            fi

            cd "$dir" 2>/dev/null || continue
            local branch=$(git branch --show-current 2>/dev/null || echo "unknown")
            local commit=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

            if [[ "$status" == "running" ]]; then
                echo -e "  ${GREEN}üü¢ $instance_name${NC} (branch: $branch, commit: $commit)"
            else
                echo -e "  ${YELLOW}üü° $instance_name${NC} (branch: $branch, commit: $commit)"
            fi
        fi
    done
}

# Function to clean up
cleanup() {
    log_header "Cleaning up Dopemux instances"

    # Remove stopped containers
    log_info "Removing stopped containers..."
    docker container prune -f --filter "label=mcp.instance" 2>/dev/null || true

    # Remove unused networks
    log_info "Removing unused networks..."
    docker network prune -f 2>/dev/null || true

    log_success "Cleanup completed"
}

# Main command handler
main() {
    local command="${1:-}"

    case "$command" in
        "start")
            start_instance "${2:-}" "${3:-main}"
            ;;
        "stop")
            stop_instance "${2:-}"
            ;;
        "status")
            show_status
            ;;
        "list")
            list_instances
            ;;
        "switch")
            switch_instance "${2:-}"
            ;;
        "clean")
            cleanup
            ;;
        "")
            # No command provided - show status and offer to start
            show_status
            echo
            log_info "Commands:"
            echo "  dopemux start [instance] [branch]  - Start new instance"
            echo "  dopemux stop <instance>            - Stop instance"
            echo "  dopemux switch <instance>          - Switch to worktree"
            echo "  dopemux list                       - List all instances"
            echo "  dopemux clean                      - Clean up resources"
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            echo "Available commands:"
            echo "  start [instance] [branch]  - Start or create instance"
            echo "  stop <instance>            - Stop instance"
            echo "  status                     - Show all instances"
            echo "  list                       - List available instances"
            echo "  switch <instance>          - Switch to instance worktree"
            echo "  clean                      - Clean up stopped instances"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"